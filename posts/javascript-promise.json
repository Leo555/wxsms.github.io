{"meta":{"id":"javascript-promise","title":"JavaScript Promise","date":"2016-09-05T17:27:26.000Z","categories":["JavaScript"],"tags":["Async","ES6","Promise"]},"html":"<p>知乎上有一个黑 JavaScript 的段子，大概是说：</p>\n<blockquote>\n<p>N 年后，外星人截获了 NASA 发射的飞行器并破解其源代码，翻到最后发现好几页的 }}}}}}&#8230;&#8230;</p>\n</blockquote>\n<p>这是因为 NASA 近年发射过使用 JavaScript 编程的飞行器，而 Node.js 环境下的 JavaScript 有个臭名昭著的特色：Callback hell（回调地狱的意思）</p>\n<p>JavaScript Promise 是一种用来取代超长回调嵌套编程风格（特指 Node.js）的解决方案。</p>\n<p>比如：</p>\n<pre><code>getAsync(<span class=\"hljs-string\">\"/api/something\"</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">(<span class=\"hljs-built_in\">error</span>, result)</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">error</span>){\n        //<span class=\"hljs-built_in\">error</span>\n    }\n    //success\n});\n</code></pre><p>将可以写作：</p>\n<pre><code>let promise = getAsyncPromise(<span class=\"hljs-string\">\"/api/something\"</span>); \npromise.<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(result)</span> =&gt;</span> {\n    //success\n}).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">(<span class=\"hljs-built_in\">error</span>)</span> =&gt;</span> {\n    //<span class=\"hljs-built_in\">error</span>\n});\n</code></pre><p>乍一看好像并没有什么区别，依然是回调。但最近在做的一个东西让我明白，Promise 的目的不是为了干掉回调函数，而是为了干掉嵌套回调函数。</p>\n<!--more-->\n<h2 role=\"anchor\">\n            <a name=\"定义\" role=\"anchor\">定义</a>\n          </h2><p>MDN 定义：</p>\n<blockquote>\n<p>The Promise object is used for asynchronous computations. A Promise represents a value which may be available now, or in the future, or never.</p>\n</blockquote>\n<p>意思大概就是，Promise 是专门用于异步处理的对象。一个 Promise 代表着一个值，这个值可能已经获得了，又可能在将来的某个时刻会获得，又或者永远都无法获得。</p>\n<p>简单地说，Promise 对象就是值的代理。经纪人。</p>\n<h2 role=\"anchor\">\n            <a name=\"简单用法\" role=\"anchor\">简单用法</a>\n          </h2><p>创建一个 Promise：</p>\n<pre><code><span class=\"hljs-keyword\">let</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n    <span class=\"hljs-comment\">//success -&gt; resolve(data)</span>\n    <span class=\"hljs-comment\">//error -&gt; reject(data)</span>\n});\n</code></pre><p>使用 <code>new Promise</code>  来创建 Promise 对象，构造器中传入一个函数，同时对该函数传入 <code>resolve</code>  和 <code>reject</code>  参数，分别代表异步处理成功与失败时将要调用的方法。</p>\n<p>处理 Promise 结果：</p>\n<pre><code><span class=\"hljs-keyword\">promise</span>.<span class=\"hljs-built_in\">then</span>(onFulfilled, onRejected)\n</code></pre><p>使用 <code>then</code>  方法来注册结果函数，共可以注册两个函数，其中 <code>onFulfilled</code>  代表成功，后者代表失败。两个参数都是可选参数。</p>\n<p>不过，对于失败处理，更加推荐的方式是使用 <code>catch</code>  方法：</p>\n<pre><code><span class=\"hljs-keyword\">promise</span>.<span class=\"hljs-built_in\">catch</span>(onRejected)\n</code></pre><p>这两个方法可以进行链式操作。组合示例：</p>\n<pre><code>function asyncFunction() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Promise(<span class=\"hljs-function\"><span class=\"hljs-params\">(resolve, reject)</span> =&gt;</span> {\n        setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n            resolve(<span class=\"hljs-string\">'Async Hello world'</span>);\n        }, <span class=\"hljs-number\">1000</span>);\n    });\n}\n\nasyncFunction()\n    .<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(value)</span> =&gt;</span> {\n        <span class=\"hljs-built_in\">console</span>.log(value); <span class=\"hljs-regexp\">//</span>Async Hello world\n    })\n    .<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(error)</span> =&gt;</span> {\n        <span class=\"hljs-built_in\">console</span>.log(error);\n    });\n</code></pre><p>这里使用了定时器来模拟异步过程，实际上其它异步过程（如 XHR）也大概都是这么个写法。</p>\n<h2 role=\"anchor\">\n            <a name=\"状态\" role=\"anchor\">状态</a>\n          </h2><p>Promise 对象共有三种状态：</p>\n<ul>\n<li>Fulfilled （成功）</li>\n<li>Rejected （失败）</li>\n<li>Pending （处理中）</li>\n</ul>\n<p>有两条转换路径：</p>\n<ul>\n<li>Pending -&gt; Fulfilled -&gt; <code>then</code>  call</li>\n<li>Pending -&gt; Rejected -&gt; <code>catch</code>  call</li>\n</ul>\n<p>Promise 对象的状态，从 Pending 转换为 Fulfilled 或 Rejected 之后， <code>then</code>  方法或者 <code>catch</code>  方法就会被立即调用，并且这个 promise 对象的状态不会再发生任何变化。也就是说，调用且只调用一次。</p>\n<h2 role=\"anchor\">\n            <a name=\"链式操作\" role=\"anchor\">链式操作</a>\n          </h2><p>链式操作是 Promise 对象的一大亮点。</p>\n<p>本节引用一些 <a href=\"https://github.com/azu/promises-book\" target=\"_blank\"><em>Promise Book</em></a> 的内容。</p>\n<p>例如：</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">taskA</span><span class=\"hljs-params\">()</span> {</span>\n    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">\"Task A\"</span>);\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">taskB</span><span class=\"hljs-params\">()</span> {</span>\n    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">\"Task B\"</span>);\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">onRejected</span><span class=\"hljs-params\">(error)</span> {</span>\n    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">\"Catch Error: A or B\"</span>, <span class=\"hljs-built_in\">error</span>);\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">finalTask</span><span class=\"hljs-params\">()</span> {</span>\n    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">\"Final Task\"</span>);\n}\n\nvar promise = Promise.resolve();\npromise\n    .<span class=\"hljs-keyword\">then</span>(taskA)\n    .<span class=\"hljs-keyword\">then</span>(taskB)\n    .<span class=\"hljs-keyword\">catch</span>(onRejected)\n    .<span class=\"hljs-keyword\">then</span>(finalTask);\n\n<span class=\"hljs-comment\">//Task A</span>\n<span class=\"hljs-comment\">//Task B</span>\n<span class=\"hljs-comment\">//Final Task</span>\n</code></pre><p>该代码块实际流程如图所示：</p>\n<p><img src=\"/static/images/promise-then-catch-flow.png\" alt=\"\"></p>\n<p>&nbsp;</p>\n<p>可以看到，这个 onRejected 并不仅仅是 TaskB 的失败处理函数，同时它也是 TaskA 的失败处理函数。而且当 TaskA 失败（reject 被调用或者抛出异常）时，TaskB 将不会被调用，直接进入失败处理。熟悉 express 的玩家应该能看出来了，这简直就和中间件一模一样嘛。</p>\n<p>比如说，TaskA 出现异常：</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">taskA</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Task A\"</span>);\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">\"throw Error @ Task A\"</span>)\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">taskB</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Task B\"</span>);<span class=\"hljs-comment\">// 不会被调用</span>\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">onRejected</span>(<span class=\"hljs-params\">error</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(error);<span class=\"hljs-comment\">// =&gt; \"throw Error @ Task A\"</span>\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">finalTask</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Final Task\"</span>);\n}\n\n<span class=\"hljs-keyword\">var</span> promise = <span class=\"hljs-built_in\">Promise</span>.resolve();\npromise\n    .then(taskA)\n    .then(taskB)\n    .catch(onRejected)\n    .then(finalTask);\n</code></pre><p>这里的输出应该就是：</p>\n<pre><code><span class=\"hljs-comment\">//Task A</span>\n<span class=\"hljs-comment\">//Error: throw Error @ Task A</span>\n<span class=\"hljs-comment\">//Final Task</span>\n</code></pre><p>需要注意的是，如果在 <code>onRejected</code>  或 <code>finalTask</code>  中出现异常，那么这个异常将不会再被捕捉到。因为并没有再继续注册 <code>catch</code>  函数。</p>\n<p>借助 Promise 链式操作的特点，复杂的 JavaScript 回调简化将不再是梦。</p>\n<h2 role=\"anchor\">\n            <a name=\"递归\" role=\"anchor\">递归</a>\n          </h2><p>Promise 可以实现递归调用，在用来一次性抓取所有分页内容的时候有用。例：</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">get</span><span class=\"hljs-params\">(url, p)</span> {</span>\n  <span class=\"hljs-keyword\">return</span> $.get(url + <span class=\"hljs-string\">\"?page=\"</span> + p)\n      .<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(data)</span> {</span>\n          <span class=\"hljs-keyword\">if</span>(!data.list.<span class=\"hljs-built_in\">length</span>) {\n              <span class=\"hljs-keyword\">return</span> [];\n          }\n\n          <span class=\"hljs-keyword\">return</span> get(url, p+<span class=\"hljs-number\">1</span>)\n              .<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(nextList)</span> {</span>\n                  <span class=\"hljs-keyword\">return</span> [].concat(data.<span class=\"hljs-built_in\">list</span>, nextList);\n              });\n      });\n}\n\nget(<span class=\"hljs-string\">\"urlurl\"</span>, <span class=\"hljs-number\">1</span>).<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(list)</span> {</span>\n    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-built_in\">list</span>);<span class=\"hljs-comment\">//your full list is here</span>\n});\n</code></pre><h2 role=\"anchor\">\n            <a name=\"实用方法\" role=\"anchor\">实用方法</a>\n          </h2><h3 role=\"anchor\">\n            <a name=\"Promise-all\" role=\"anchor\">Promise.all</a>\n          </h3><p><code>Promise.all</code>  接受一个 promise 对象的数组作为参数，当这个数组里的所有promise对象全部变为 resolve 或 reject 状态的时候，它才会去调用 <code>then</code>  方法。</p>\n<p>例：</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">taskA</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n        setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'TaskA resolved!'</span>);\n            resolve();\n        }, <span class=\"hljs-number\">1000</span>);\n    });\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">taskB</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n        setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'TaskB resolved!'</span>);\n            resolve();\n        }, <span class=\"hljs-number\">2000</span>);\n    });\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.all([taskA(), taskB()]);\n}\n\nmain()\n    .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> {\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'All resolved!'</span>);\n    })\n    .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> {\n        <span class=\"hljs-built_in\">console</span>.log(error);\n    });\n\n<span class=\"hljs-comment\">//TaskA resolved!</span>\n<span class=\"hljs-comment\">//TaskB resolved!</span>\n<span class=\"hljs-comment\">//All resolved!</span>\n</code></pre><h3 role=\"anchor\">\n            <a name=\"Promise-race\" role=\"anchor\">Promise.race</a>\n          </h3><p>跟 <code>Promise.all</code>  类似，略有区别，从名字就能看出来，只要有一个 Task 执行完毕，整个 Promise 就会返回。但是需要注意的是，返回以后并不会取消其它未完成的 Promise 的执行。</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">taskA</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n        setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'TaskA resolved!'</span>);\n            resolve();\n        }, <span class=\"hljs-number\">1000</span>);\n    });\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">taskB</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n        setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'TaskB resolved!'</span>);\n            resolve();\n        }, <span class=\"hljs-number\">2000</span>);\n    });\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.race([taskA(), taskB()]);\n}\n\nmain()\n    .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> {\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'All resolved!'</span>);\n    })\n    .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> {\n        <span class=\"hljs-built_in\">console</span>.log(error);\n    });\n\n<span class=\"hljs-comment\">//TaskA resolved!</span>\n<span class=\"hljs-comment\">//All resolved!</span>\n<span class=\"hljs-comment\">//TaskB resolved!</span>\n</code></pre><h2 role=\"anchor\">\n            <a name=\"支持性\" role=\"anchor\">支持性</a>\n          </h2><p>由于是 ES6 语法，目前在浏览器端支持不是特别好，很多移动端浏览器以及 IE 家族均不支持（具体可查看 MDN）。如果要在浏览器端使用需要借助 Babel 编译器。</p>\n<p>至于 Node.js 环境则毫无问题。</p>\n"}
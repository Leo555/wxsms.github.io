{"meta":{"id":"react-note-basic","title":"React Note - Basic","date":"2017-02-08T11:33:00.000Z","index":true,"categories":["JavaScript"],"tags":["React"]},"html":"<p>React 学习笔记（基础篇）。</p>\n<!--more-->\n<h2 role=\"anchor\">\n            <a name=\"安装\" role=\"anchor\">安装</a>\n          </h2><pre><code class=\"lang-bash\"><span class=\"hljs-string\">npm </span><span class=\"hljs-string\">install </span>-g <span class=\"hljs-built_in\">create-react-app</span>\n<span class=\"hljs-built_in\">create-react-app</span> <span class=\"hljs-string\">hello-world\n</span><span class=\"hljs-string\">cd </span><span class=\"hljs-string\">hello-world\n</span><span class=\"hljs-string\">npm </span><span class=\"hljs-string\">start</span>\n</code></pre>\n<p>实践：create 这一步会同时执行 <code>npm install</code> 因此有失败的可能，多尝试几次就成功了。</p>\n<p>这个程序跟 vue-loader 很像，会造出一个简单的手脚架，包含了 Babel 编译器以及打包工具等等。但是细看它的 <code>package.json</code> 文件并没有包含上述内容：</p>\n<pre><code class=\"lang-json\"><span class=\"hljs-string\">\"devDependencies\"</span>: {\n  <span class=\"hljs-string\">\"react-scripts\"</span>: <span class=\"hljs-string\">\"0.8.5\"</span>\n},\n<span class=\"hljs-string\">\"dependencies\"</span>: {\n  <span class=\"hljs-string\">\"react\"</span>: <span class=\"hljs-string\">\"^15.4.2\"</span>,\n  <span class=\"hljs-string\">\"react-dom\"</span>: <span class=\"hljs-string\">\"^15.4.2\"</span>\n}\n</code></pre>\n<p>因此，跟 vue-loader 不一样的是，react 这个手脚架把无关内容都封装了。这么做我觉得有利有弊：它让人用起来更方便，然而不可能达到直接使用原组件的自由度了。相比之下，这里我更喜欢 vue-loader 的处理方式。</p>\n<h2 role=\"anchor\">\n            <a name=\"Hello-World\" role=\"anchor\">Hello World</a>\n          </h2><p>最简示例：</p>\n<pre><code class=\"lang-js\">ReactDOM.render(\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, world!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>,\n  <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'root'</span>)\n);\n</code></pre>\n<h2 role=\"anchor\">\n            <a name=\"JSX-语法\" role=\"anchor\">JSX 语法</a>\n          </h2><p>JSX 是 JavaScript 的一种语法扩展，实际上可以看做是语法糖。通过编译器，以下语法：</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> element = (\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"greeting\"</span>&gt;</span>\n    Hello, world!\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n);\n</code></pre>\n<p>相当于：</p>\n<pre><code class=\"lang-js\">const <span class=\"hljs-literal\">element</span> = {\n  type: <span class=\"hljs-string\">'h1'</span>,\n  props: {\n    className: <span class=\"hljs-string\">'greeting'</span>,\n    children: <span class=\"hljs-string\">'Hello, world'</span>\n  }\n};\n</code></pre>\n<p>后者就是编译后的结果，JSX 语法块变成了一个对象（称之为 <code>React element</code>）。</p>\n<p>（JB 家的 IDE 已经对 JSX 语法提供了默认支持，不然这篇笔记就到此为止了）</p>\n<p>JSX 支持一些稍微高级的用法，如：</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">formatName</span>(<span class=\"hljs-params\">user</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> user.firstName + <span class=\"hljs-string\">' '</span> + user.lastName;\n}\n\n<span class=\"hljs-keyword\">const</span> user = {\n  <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">'Harper'</span>,\n  <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">'Perez'</span>\n};\n\n<span class=\"hljs-keyword\">const</span> element = (\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>\n    Hello, {formatName(user)}!\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>\n);\n\nReactDOM.render(\n  element,\n  <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'root'</span>)\n);\n</code></pre>\n<p>在任何地方使用 JSX：</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getGreeting</span>(<span class=\"hljs-params\">user</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (user) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, {formatName(user)}!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, Stranger.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n}\n</code></pre>\n<h2 role=\"anchor\">\n            <a name=\"元素\" role=\"anchor\">元素</a>\n          </h2><p>上面有说到 <code>React element</code>（元素），<strong>元素</strong>的概念与<strong>组件</strong>不同：元素是组件的组成部分。</p>\n<h3 role=\"anchor\">\n            <a name=\"元素渲染\" role=\"anchor\">元素渲染</a>\n          </h3><pre><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> element = <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, world<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\nReactDOM.render(\n  element,\n  <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'root'</span>)\n);\n</code></pre>\n<p>显然，它掌控了 DOM 中一个 ID 为 root 的节点，并往里面插入了元素。</p>\n<h3 role=\"anchor\">\n            <a name=\"元素更新\" role=\"anchor\">元素更新</a>\n          </h3><p><strong>已创建的元素是无法更新属性的</strong>。因此，如果要改变它，只能够重新创建并渲染一次。</p>\n<p>然而，托虚拟 DOM 的福，重新渲染并不代表重新渲染整个 DOM，React 会查找并只更新有改变的节点。</p>\n<p>但是一般不回这么做。因为有一点很重要：在设计一个元素的时候就要考虑到它在所有状态下的表现。这个其实在其它框架下也是一样的。</p>\n<h2 role=\"anchor\">\n            <a name=\"组件\" role=\"anchor\">组件</a>\n          </h2><p>React 是组件化框架，因此组件是组成一个应用的基础。组件的特点：独立、可重用。</p>\n<p>组件有两种定义方法：</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Welcome</span>(<span class=\"hljs-params\">props</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, {props.name}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n}\n</code></pre>\n<p>或者：</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Welcome</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  render() {\n    <span class=\"hljs-keyword\">return</span> &lt;h1&gt;<span class=\"hljs-type\">Hello</span>, {<span class=\"hljs-keyword\">this</span>.props.name}&lt;/h1&gt;;\n  }\n}\n</code></pre>\n<h3 role=\"anchor\">\n            <a name=\"组件渲染\" role=\"anchor\">组件渲染</a>\n          </h3><p>一个简单的例子：</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Welcome</span>(<span class=\"hljs-params\">props</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, {props.name}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></span>;\n}\n\n<span class=\"hljs-keyword\">const</span> element = <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Welcome</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"Sara\"</span> /&gt;</span>;\n\nReactDOM.render(\n  element,\n  document.getElementById('root')\n);</span>\n</code></pre>\n<p>可以看到元素组成了组件，组件又组成了元素，最后渲染在 DOM 上的是元素。</p>\n<p>这个跟 Vue 很像了，区别是 Vue 没有区分所谓的“元素”跟“组件”，通通都是组件。</p>\n<p>需要注意的是，在 React 世界中有个约定：自定义控件以大写字母打头。这是为了跟 HTML 元素有所区分。</p>\n<h3 role=\"anchor\">\n            <a name=\"组件使用与拆解\" role=\"anchor\">组件使用与拆解</a>\n          </h3><p>一个简单的例子：</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Welcome</span>(props) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">&lt;h1&gt;Hello,</span> {props.name}&lt;/h1&gt;;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>() {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">(</span>\n    &lt;div&gt;\n      &lt;Welcome name=<span class=\"hljs-string\">\"Sara\"</span> /&gt;\n      &lt;Welcome name=<span class=\"hljs-string\">\"Cahal\"</span> /&gt;\n      &lt;Welcome name=<span class=\"hljs-string\">\"Edite\"</span> /&gt;\n    &lt;/div&gt;\n  );\n}\n\nReactDOM.render(\n  &lt;App /&gt;,\n  document.getElementById(<span class=\"hljs-symbol\">'root</span>')\n);\n</code></pre>\n<p>需要注意的是，组件只能有一个根节点。（如例子中的 3 个 <code>Welcome</code> 必须包裹在 <code>div</code> 中）</p>\n<h3 role=\"anchor\">\n            <a name=\"参数只读\" role=\"anchor\">参数只读</a>\n          </h3><p>简单地说，React 不允许在控件内修改参数（包括值的修改以及对象修改）。允许修改的称之为“状态”（约等于 Vue 中的 component data）</p>\n<h2 role=\"anchor\">\n            <a name=\"状态管理与生命周期\" role=\"anchor\">状态管理与生命周期</a>\n          </h2><h3 role=\"anchor\">\n            <a name=\"添加状态管理\" role=\"anchor\">添加状态管理</a>\n          </h3><p>组件的更新依赖于状态，因此需要实时更新的组件应在其内部建立状态管理机制（低耦合高内聚）。</p>\n<p>需要状态管理机的组件，必须使用 ES6 方式声明，如：</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Clock</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(props) {\n    <span class=\"hljs-keyword\">super</span>(props);\n    <span class=\"hljs-keyword\">this</span>.state = {<span class=\"hljs-attr\">date</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()};\n  }\n\n  render() {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, world!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>It is {this.state.date.toLocaleTimeString()}.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    );\n  }\n}\n\nReactDOM.render(\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Clock</span> /&gt;</span>,\n  document.getElementById('root')\n);</span>\n</code></pre>\n<p>但是，此时，组件是无法更新的：因为状态在创建时就已经被决定了。</p>\n<h3 role=\"anchor\">\n            <a name=\"添加生命周期\" role=\"anchor\">添加生命周期</a>\n          </h3><p>代码有注释：</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Clock</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(props) {\n    <span class=\"hljs-keyword\">super</span>(props);\n    <span class=\"hljs-keyword\">this</span>.state = {<span class=\"hljs-attr\">date</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()};\n  }\n\n  <span class=\"hljs-comment\">// 组件渲染到 DOM 后调用</span>\n  componentDidMount() {\n    <span class=\"hljs-keyword\">this</span>.timerID = setInterval(\n      <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">this</span>.tick(),\n      <span class=\"hljs-number\">1000</span>\n    );\n  }\n\n  <span class=\"hljs-comment\">// 组件将销毁后调用</span>\n  componentWillUnmount() {\n    clearInterval(<span class=\"hljs-keyword\">this</span>.timerID);\n  }\n\n  tick() {\n    <span class=\"hljs-keyword\">this</span>.setState({\n      <span class=\"hljs-attr\">date</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>()\n    });\n  }\n\n  render() {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello, world!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>It is {this.state.date.toLocaleTimeString()}.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    );\n  }\n}\n\nReactDOM.render(\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Clock</span> /&gt;</span>,\n  document.getElementById('root')\n);</span>\n</code></pre>\n<p>整个流程很简单清晰了：</p>\n<ol>\n<li>ReactDOM 渲染 <code>Clock</code>，并对 state 做第一次初始化</li>\n<li><code>render</code> 方法被调用，插入 DOM</li>\n<li><code>componentDidMount</code> 方法被调用，计时器启动，<code>tick</code> 每秒钟执行一次</li>\n<li>每次 <code>tick</code> 执行都调用 <code>setState</code> 方法去更新状态，这样 React 就知道需要更新 DOM 了</li>\n<li>当组件被从 DOM 移除后，<code>componentWillUnmount</code> 执行</li>\n</ol>\n<h3 role=\"anchor\">\n            <a name=\"正确使用状态\" role=\"anchor\">正确使用状态</a>\n          </h3><p>直接更改 state 属性是不会触发 UI 更新的。因此，有一些规则需要遵守。</p>\n<h4 role=\"anchor\">\n            <a name=\"不直接修改状态\" role=\"anchor\">不直接修改状态</a>\n          </h4><p>在组件内进行修改状态操作，使用 <code>setState</code> 方法：</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-comment\">// Wrong</span>\n<span class=\"hljs-keyword\">this</span>.state.comment = <span class=\"hljs-string\">'Hello'</span>;\n\n<span class=\"hljs-comment\">// Correct</span>\n<span class=\"hljs-keyword\">this</span>.setState({comment: <span class=\"hljs-string\">'Hello'</span>});\n</code></pre>\n<h4 role=\"anchor\">\n            <a name=\"关于异步更新\" role=\"anchor\">关于异步更新</a>\n          </h4><pre><code class=\"lang-js\"><span class=\"hljs-comment\">// Wrong</span>\n<span class=\"hljs-keyword\">this</span>.setState({\n  counter: <span class=\"hljs-keyword\">this</span>.state.counter + <span class=\"hljs-keyword\">this</span>.props.increment,\n});\n\n<span class=\"hljs-comment\">// Correct</span>\n<span class=\"hljs-keyword\">this</span>.setState((prevState, props) =&gt; ({\n  counter: prevState.counter + props.increment\n}));\n</code></pre>\n<h4 role=\"anchor\">\n            <a name=\"状态合并\" role=\"anchor\">状态合并</a>\n          </h4><p>在进行 <code>setState</code> 的时候，只关心需要更改的属性即可，没有传入的属性会被保留。就好像新的状态被“合并”进入旧状态一样。</p>\n<h3 role=\"anchor\">\n            <a name=\"数据流\" role=\"anchor\">数据流</a>\n          </h3><p>在 React 世界，组件与组件之间的状态传递是单向的，传值的方式就是将 state 当做 prop 传给子组件。</p>\n<h2 role=\"anchor\">\n            <a name=\"事件处理\" role=\"anchor\">事件处理</a>\n          </h2><p>跟 DOM 操作很像，区别：</p>\n<ol>\n<li>事件命名使用驼峰式</li>\n<li>直接向 JSX 中传入方法</li>\n<li>不支持 <code>return false</code> 操作</li>\n</ol>\n<p>例：</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-comment\">// DOM</span>\n&lt;button onclick=<span class=\"hljs-string\">\"activateLasers()\"</span>&gt;\n  <span class=\"hljs-type\">Activate</span> <span class=\"hljs-type\">Lasers</span>\n&lt;/button&gt;\n\n<span class=\"hljs-comment\">// React</span>\n&lt;button onClick={activateLasers}&gt;\n  <span class=\"hljs-type\">Activate</span> <span class=\"hljs-type\">Lasers</span>\n&lt;/button&gt;\n\n<span class=\"hljs-comment\">// A prevent default sample</span>\nfunction <span class=\"hljs-type\">ActionLink</span>() {\n  function handleClick(e) {\n    e.preventDefault();\n    console.log(<span class=\"hljs-symbol\">'The</span> link was clicked.');\n  }\n\n  <span class=\"hljs-keyword\">return</span> (\n    &lt;a href=<span class=\"hljs-string\">\"#\"</span> onClick={handleClick}&gt;\n      <span class=\"hljs-type\">Click</span> me\n    &lt;/a&gt;\n  );\n}\n\n<span class=\"hljs-comment\">// A class sample</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Toggle</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  constructor(props) {\n    <span class=\"hljs-keyword\">super</span>(props);\n    <span class=\"hljs-keyword\">this</span>.state = {isToggleOn: <span class=\"hljs-literal\">true</span>};\n\n    <span class=\"hljs-comment\">// This binding is necessary to make `this` work in the callback</span>\n    <span class=\"hljs-keyword\">this</span>.handleClick = <span class=\"hljs-keyword\">this</span>.handleClick.bind(<span class=\"hljs-keyword\">this</span>);\n  }\n\n  handleClick() {\n    <span class=\"hljs-keyword\">this</span>.setState(prevState =&gt; ({\n      isToggleOn: !prevState.isToggleOn\n    }));\n  }\n\n  render() {\n    <span class=\"hljs-keyword\">return</span> (\n      &lt;button onClick={<span class=\"hljs-keyword\">this</span>.handleClick}&gt;\n        {<span class=\"hljs-keyword\">this</span>.state.isToggleOn ? <span class=\"hljs-symbol\">'O</span>N' : <span class=\"hljs-symbol\">'OF</span>F'}\n      &lt;/button&gt;\n    );\n  }\n}\n</code></pre>\n<p>注意：这个 <code>e</code> 是 React 封装过的，但遵循 W3C 标准，因此无需做浏览器差异化处理。</p>\n<p>另外，<code>this.handleClick.bind</code> 方法是为了保证在 <code>onClick</code> 中调用了正确的 <code>this</code>，但使用箭头函数可以避免这个累赘的方法：</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LoggingButton</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-comment\">// This syntax ensures `this` is bound within handleClick.</span>\n  <span class=\"hljs-comment\">// Warning: this is *experimental* syntax.</span>\n  handleClick = () =&gt; {\n    console.log(<span class=\"hljs-symbol\">'this</span> is:', <span class=\"hljs-keyword\">this</span>);\n  }\n\n  render() {\n    <span class=\"hljs-keyword\">return</span> (\n      &lt;button onClick={<span class=\"hljs-keyword\">this</span>.handleClick}&gt;\n        <span class=\"hljs-type\">Click</span> me\n      &lt;/button&gt;\n    );\n  }\n}\n</code></pre>\n<h2 role=\"anchor\">\n            <a name=\"条件渲染\" role=\"anchor\">条件渲染</a>\n          </h2><p>例子：</p>\n<pre><code class=\"lang-js\">render() {\n  const isLoggedIn = <span class=\"hljs-keyword\">this</span>.state.isLoggedIn;\n\n  let button = <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-keyword\">if</span> (isLoggedIn) {\n    button = &lt;LogoutButton onClick={<span class=\"hljs-keyword\">this</span>.handleLogoutClick} /&gt;;\n  } <span class=\"hljs-keyword\">else</span> {\n    button = &lt;LoginButton onClick={<span class=\"hljs-keyword\">this</span>.handleLoginClick} /&gt;;\n  }\n\n  <span class=\"hljs-keyword\">return</span> (\n    &lt;div&gt;\n      &lt;Greeting isLoggedIn={isLoggedIn} /&gt;\n      {button}\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<h3 role=\"anchor\">\n            <a name=\"行内判断\" role=\"anchor\">行内判断</a>\n          </h3><p>例子：</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Mailbox</span>(<span class=\"hljs-params\">props</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> unreadMessages = props.unreadMessages;\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Hello!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n      {unreadMessages.length &gt; 0 &amp;&amp;\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>\n          You have {unreadMessages.length} unread messages.\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n      }\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">const</span> messages = [<span class=\"hljs-string\">'React'</span>, <span class=\"hljs-string\">'Re: React'</span>, <span class=\"hljs-string\">'Re:Re: React'</span>];\nReactDOM.render(\n  <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Mailbox</span> <span class=\"hljs-attr\">unreadMessages</span>=<span class=\"hljs-string\">{messages}</span> /&gt;</span>,\n  document.getElementById('root')\n);</span>\n</code></pre>\n<p>这段代码的工作方式跟 JavaScript 一致：</p>\n<ul>\n<li><code>true &amp;&amp; expression</code> -&gt; <code>expression</code></li>\n<li><code>false &amp;&amp; expression</code> -&gt; <code>false</code></li>\n</ul>\n<p>因此，当 <code>unreadMessages.length &gt; 0</code> 为真时，后面的 JSX 会被渲染，反则不会。</p>\n<p>除此以外还有三元表达式：</p>\n<pre><code class=\"lang-js\">render() {\n  const isLoggedIn = this.<span class=\"hljs-keyword\">state</span>.isLoggedIn;\n  return (\n    <span class=\"hljs-variable\">&lt;div&gt;</span>\n      The <span class=\"hljs-keyword\">user</span> is <span class=\"hljs-variable\">&lt;b&gt;</span>{isLoggedIn ? 'currently' : 'not'}&lt;/b&gt; logged <span class=\"hljs-keyword\">in</span>.\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<h3 role=\"anchor\">\n            <a name=\"阻止渲染\" role=\"anchor\">阻止渲染</a>\n          </h3><p>在组件的 <code>render</code> 方法内 <code>return null</code> 会阻止组件的渲染，但是其生命周期不受影响。</p>\n<h2 role=\"anchor\">\n            <a name=\"循环\" role=\"anchor\">循环</a>\n          </h2><p>一个简单的例子：</p>\n<pre><code class=\"lang-js\"><span class=\"xml\">const numbers = [1, 2, 3, 4, 5];\nconst listItems = numbers.map((number) =&gt;\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span></span><span class=\"hljs-template-variable\">{number}</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n);\n\nReactDOM.render(\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span></span><span class=\"hljs-template-variable\">{listItems}</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>,\n  document.getElementById('root')\n);</span>\n</code></pre>\n<h3 role=\"anchor\">\n            <a name=\"循环组件\" role=\"anchor\">循环组件</a>\n          </h3><p>一个列表组件示例：</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">NumberList</span><span class=\"hljs-params\">(props)</span> </span>{\n  <span class=\"hljs-keyword\">const</span> numbers = props.numbers;\n  <span class=\"hljs-keyword\">const</span> listItems = numbers.map((number) =&gt;\n    &lt;li key={number.toString()}&gt;\n      {number}\n    &lt;/li&gt;\n  );\n  <span class=\"hljs-keyword\">return</span> (\n    &lt;ul&gt;{listItems}&lt;/ul&gt;\n  );\n}\n\n<span class=\"hljs-keyword\">const</span> numbers = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\nReactDOM.render(\n  &lt;NumberList numbers={numbers} /&gt;,\n  document.getElementById(<span class=\"hljs-string\">'root'</span>)\n);\n</code></pre>\n<p>注意，这里对列表项添加了一个 <code>key</code> 属性。</p>\n<h3 role=\"anchor\">\n            <a name=\"Key\" role=\"anchor\">Key</a>\n          </h3><p><code>Key</code> 是 React 用来追踪列表项的一个属性。跟 angular 以及 vue 中 <code>track-by</code> 的概念一样。</p>\n<p>如果列表项没有唯一标识，也可以用索引作为 key （不推荐）：</p>\n<pre><code class=\"lang-js\">const todoItems = todos.map(<span class=\"hljs-function\"><span class=\"hljs-params\">(todo, index)</span> =&gt;</span>\n  <span class=\"hljs-regexp\">//</span> Only <span class=\"hljs-keyword\">do</span> <span class=\"hljs-keyword\">this</span> <span class=\"hljs-keyword\">if</span> items have <span class=\"hljs-literal\">no</span> stable IDs\n  &lt;li key={index}&gt;\n    {todo.text}\n  &lt;/li&gt;\n);\n</code></pre>\n<p>注意：<code>Key</code> 只能直接在数组循环体内定义。如：</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\">function <span class=\"hljs-title\">ListItem</span>(<span class=\"hljs-params\">props</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">value</span> = props.<span class=\"hljs-keyword\">value</span>;\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"hljs-comment\">// Wrong! There is no need to specify the key here:</span>\n    &lt;li key={<span class=\"hljs-keyword\">value</span>.toString()}&gt;\n      {<span class=\"hljs-keyword\">value</span>}\n    &lt;/li&gt;\n  );\n}\n\n<span class=\"hljs-function\">function <span class=\"hljs-title\">NumberList</span>(<span class=\"hljs-params\">props</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> numbers = props.numbers;\n  <span class=\"hljs-keyword\">const</span> listItems = numbers.map((number) =&gt;\n    <span class=\"hljs-comment\">// Wrong! The key should have been specified here:</span>\n    &lt;ListItem <span class=\"hljs-keyword\">value</span>={number} /&gt;\n  );\n  <span class=\"hljs-keyword\">return</span> (\n    &lt;ul&gt;\n      {listItems}\n    &lt;/ul&gt;\n  );\n}\n</code></pre>\n"}